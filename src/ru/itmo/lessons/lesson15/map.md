## Map используются для хранения данных в парах: ключ-значение

При выборе конкретного типа map следует учитывать:

* безопасность использования в многопоточных средах;
* необходимость в хранении элементов в определенном порядке: в порядке добавления, в отсортированном по ключам виде и
  т.д.;
* скорость добавления, удаления, извлечения элементов.

### Все классы, описывающие map, реализуют интерфейс Map и имеют общие особенности.

* ключи должны быть уникальны
* каждый ключ может отображать только одно значение
* каждое значение можно найти по его ключу
* Map не расширяет интерфейс Collection
* порядок хранения элементов зависит от конкретной реализации

**Некоторые методы интерфейса Map<K,V>**:

* `void clear()` - удаляет все пары (ключ-значение)
* `boolean containsKey(Object key)` - возвращает true, если ключ содержится в map
* `boolean containsValue(Object value)` - возвращает true, если ключ содержится в map
* `V get(Object key)` - возвращает значение по ключу или null, если ключ в map отсутствует
* `V getOrDefault(Object key, V defaultValue)` - возвращает значение по ключу или defaultValue, если ключ в map
  отсутствует
* `V put(K key, V value)` - добавляет пару (ключ-значение). Если ключ уже есть в map, значение будет перезаписано
* `void putAll(Map<? extends K,? extends V> map)`
* `V remove(Object key)` - удаляет пару (ключ-значение) по
* `boolean remove(Object key, Object value)`
* `V replace(K key, V value)` - заменяет значение по ключу. Возвращает null, если ключ отсутствует
* `boolean replace(K key, V oldValue, V newValue)` - заменяет значение oldValue на newValue, если oldValue ассоциировано
  с ключом key
* `int size()` - возвращает количество пар (ключ-значение)
* `Collection<V> values()` - возвращает коллекцию значений
* `Set<K> keySet()` - возвращает множество ключей
* `Set<Map.Entry<K,V>> entrySet()` - возвращает пары (ключ-значение)

Есть возможность создавать неизменяемые map: методы Map.of, Map.ofEntries, and Map.copyOf

***При изучении методов необходимо учитывать версию java и особенности их реализации в конкретных классах.*** Например,
методы, принимающие на вход ключ могут выбрасывать NullPointerException, если map не позволяет хранить null в качестве
ключа.

### Создание экземпляров map

Наиболее популярные **непотокобезопасные реализации**: `HashMap`, `EnumMap`, `WeakHashMap`, `TreeMap`, `LinkedHashMap`

1. Все map можно создать

1) **пустыми** (использовать конструктор без параметров)
2) **на основе пар другой map** (использовать конструктор, который принимает на вход другую map)
3) некоторые классы обладают **дополнительными конструкторами** (например, позволяющие задавать порядок сортировки
   ключей у TreeMap).

2. Все map типизированы (generic), при создании экземпляра необходимо указывать, какой тип данных будет храниться в map.
3. В map нельзя хранить примитивные типы данных.

### HashMap

1. хранит ключи в hash-таблице (использует hashCode() ключей для размещения элементов)
2. имеет хорошую производительность
3. порядок хранения элементов может отличаться от порядка их добавления
4. в классах, экземпляры которые используются в качестве ключей обязательно должны быть переопределены методы equals и
   hashCode
5. null можно использовать в качестве ключа

**Конструкторы**:

1. `HashMap()` - создает пустую map, емкость - 16, фактор загрузки - 0.75
2. `HashMap(int initialCapacity)` - создает пустую map, емкость - initialCapacity, фактор загрузки - 0.75
3. `HashMap(int initialCapacity, float loadFactor)` - создает пустую map, емкость - initialCapacity, фактор загрузки -
   loadFactor
4. `HashMap(Map<? extends K,? extends V> map)` - создание map с элементами другой map, фактор загрузки - 0.75

* **Фактор загрузки** - показатель того, на сколько заполненным может быть HashMap до того момента, когда ее емкость
  автоматически увеличится.
* **Начальная емкость** - изначальное количество ячеек (корзин) в хэш-таблице.

### LinkedHashMap

1. хранит ключи в hash-таблице (использует hashCode() ключей для размещения элементов)
2. имеет меньшую производительность по сравнению с HashMap
3. при переборе порядок доступ к элементам будет соответствовать порядку добавления
4. в классах, экземпляры которые используются в качестве ключей обязательно должны быть переопределены методы equals и
   hashCode
5. null можно использовать в качестве ключа

**Конструкторы**:

1. `LinkedHashMap()` - создает пустую map, емкость - 16, фактор загрузки - 0.75
2. `LinkedHashMap(int initialCapacity)` - создает пустую map, емкость - initialCapacity, фактор загрузки - 0.75
3. `LinkedHashMap(int initialCapacity, float loadFactor)` - создает пустую map, емкость - initialCapacity, фактор
   загрузки - loadFactor
4. `LinkedHashMap(Map<? extends K,? extends V> map)` - создание map с элементами другой map, фактор загрузки - 0.75
5. `LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)` - создает пустую map, емкость -
   initialCapacity, фактор загрузки - loadFactor, если accessOrder имеет значение true обращение к элементу методом get
   помещает его в конец

### EnumMap

1. enum используется в качестве ключей, все ключи должны быть одного enum типа
2. null нельзя использовать в качестве ключа
3. содержит все значения в массиве (длина массива - количество элементов в enum)
4. порядок хранения элементов соответствует порядку элементов enum
5. для извлечения элемента из массива использует порядковый номер ключа (метод `ordinal()`) - `values[key.ordinal()]`
6. дает дополнительную оптимизацию производительности

**Конструкторы**:

1. `EnumMap(Class<K> keyType)` - создает пустую map, в конструктор необходимо передать ссылку на перечисление, которое
   будет использоваться в качестве ключей
2. `EnumMap(EnumMap<K,? extends V> map)` - создание map с элементами другой map, тип перечисления, которое будет
   использоваться в качестве ключей сохраняется
3. `EnumMap(Map<K,? extends V> map)` - аналогичен конструктору EnumMap(EnumMap<K,? extends V> map) или map должна
   содержать хотя бы одну пару для определения типа ключей

### TreeMap

1. хранит элементы в отсортированном по ключам виде (красно-черное бинарное дерево)
2. null не может быть использован
3. в качестве ключа класс, объекты которого являются ключами должен реализовывать Comparable интерфейс, либо объект
   Comparator должен передаваться в конструктор TreeMap

**Конструкторы**:

1. `TreeMap()` - создает пустую map, с натуральным порядком сортировки по ключам. Сортировка осуществляется благодаря
   реализации метода `compare интерфейса Comparable` у ключей
2. `TreeMap(Map<? extends K,? extends V> map)` - создание map с элементами другой map, с натуральным порядком сортировки
   по ключам. Сортировка осуществляется благодаря реализации метода `compare интерфейса Comparable` у ключей
3. `TreeMap(Comparator<? super K> comparator)` - создает пустую map. Сортировка осуществляется благодаря экземпляру
   типа `Comparator`, который `передается в конструктор`
4. `TreeMap(SortedMap<K,? extends V> map)` - создает map из элементов другой отсортированной по ключам map. Порядок
   сортировки в новой map соответствует порядку сортировки исходной.

### WeakHashMap

1. хранит ключи в hash-таблице (использует hashCode ключей для размещения элементов)
2. null можно использовать в качестве ключа
3. в классах, экземпляры которые используются в качестве ключей обязательно должны быть переопределены методы equals и
   hashCode
4. используется для кеширования
5. поведение зависит от сборщика мусора (метод size может возвращать меньшие значения с течением времени, метод isEmpty
   возвращать false, а затем true и т.п)
6. ключи удаляются сборщиком мусора после того, как на ключи не останется сильных ссылок. После этого из map удаляется и
   связанное с ключом значение

**Конструкторы**:

1. `WeakHashMap()` - создает пустую map, емкость - 16, фактор загрузки - 0.75
2. `WeakHashMap(int initialCapacity)` - создает пустую map, емкость - initialCapacity, фактор загрузки - 0.75
3. `WeakHashMap(int initialCapacity, float loadFactor)` - создает пустую map, емкость - initialCapacity, фактор загрузки -
   loadFactor
4. `WeakHashMap(Map<? extends K,? extends V> map)` - создание map с элементами другой map, фактор загрузки - 0.75